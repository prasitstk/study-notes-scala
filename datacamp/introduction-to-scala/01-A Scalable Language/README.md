# 01-A Scalable Language

## A scalable language

### What is Scala?

Scala is **a strong statically typed high-level general-purpose programming language** that supports both **object-oriented programming** and **functional programming**. 

Designed to be **concise**, many of Scala's design decisions are aimed to address criticisms of Java.

**Scala source code** is intended to be compiled to **Java bytecode**, so that the resulting executable code **runs on a Java virtual machine**.

### Why use Scala?

Scala stands for **scala**ble language. 

It is designed to grow with the demands of its users, from writing small scripts to building massive systems for **data processing**, distributed computing, and more.

### More answers to "Why use Scala?"

**Flexible**

- Scala lets you **add new types, collections, and control constructs** that feel like they are built-in to the language.

**Convenient**

- The **Scala standard library** has a set of convenient predefined types, collections, and control constructs.

**Concise**

- Scala is concise. Scala programs tend to be short, often down to one tenth of the number of lines compared to Java programs.

**High-level language**

- You won't deal with the details of the computer in your Scala code. 
- In turn, your code becomes shorter and easier to understand. 
- You have fewer opportunities to make mistakes.

**ADVANCED static type system**

- Reduces verbosity in your code and adds language flexibility. 
- These are two common criticisms of static typing.

**Compatible with Java**

- Scala is compatible, which means you can build on previously existing Java code. 
- Scala runs primarily on the Java Virtual Machine. 
- It heavily reuses Java types. 

### Who uses Scala?

Roles

- Software Engineer
- Data Engineer
- Data Scientist
- Machine Learning Engineer

Industries

- Finance
- Tech
- Healthcare

---

## Scala code and the Scala interpreter

### Scala fuses OOP and FP -> Scala is scalale

**Scala is object-oriented**

- Every value is an object
- Every operation is a method call

```scala
val sumA = 2 + 4

// Behind the scenes, Scala rewrite it:

val sumA = 2.+(4)
```

**Scala is functional**

- Functions are first-class values: just like integer or string:
  - You can pass them as arguments to other functions, return them from functions, store them in variables, and more. 

- Operations of a program should map input values to output values rather than change data in place. 
  - Another way of saying this is functions should not have side effects. 

### The Scala interpreter

Type `scala` to get into the **Scala REPL** (like scala shell).

```shell
scala> 2 + 3
# res0: Int = 5

# `res0` can be reused.
scala> res0 + 7
# res1: Int = 12

scala> println("Hello!")
#Hello!
```

> NOTE: `res0` = Result 0, an autogenerated name that refers to the result.

---

## Immutable variables (val) and value types

### Scala has two kinds of variables

1. `val` (immutable = once initialized, can't be re-assigned): a `val` is kind of like a `final` variable in Java.
2. `var` (mutable)

### Scala value types

- Double 
- Float
- Long
- Int
- Short
- Byte
- Char
- Boolean
- Unit

> NOTE: Double, Int, Boolean, String are the most common types for data-related task.
> NOTE: every value from these value types in Scala is still an object.

A type names the class in the package `scala`. 
For example, the full name of `Int` is `scala.Int`, but you can use the simple name `Int` since **the package `scala` is automatically imported into every Scala source file**.

- Double -> scala.Double 
- Float -> scala.Float
- Long -> scala.Long
- Int -> scala.Int
- Short -> scala.Short
- Byte -> scala.Byte
- Char -> scala.Char
- Boolean -> scala.Boolean
- Unit -> scala.Unit


All of these **Scala value types** (except `Unit`) have equivalent **Java primitive types** that live in the package `java.lang`.

- Double -> scala.Double -> java.lang.Double 
- Float -> scala.Float -> java.lang.Float
- Long -> scala.Long -> java.lang.Long
- Int -> scala.Int -> java.lang.Integer
- Short -> scala.Short -> java.lang.Short
- Byte -> scala.Byte -> java.lang.Byte
- Char -> scala.Char -> java.lang.Character
- Boolean -> scala.Boolean -> java.lang.Boolean
- Unit -> scala.Unit

When you compile Scala code to Java bytecode, the **Scala compiler** will use **these Java types where possible** which is HUGE for code performance.

For example:

```scala
// Define immutable variables for clubs 2♣ through 4♣
val twoClubs: Int = 2
val threeClubs: Int = 3
val fourClubs: Int = 4
```

```scala
// Define immutable variables for player names
val playerA: String = "Alex"
val playerB: String = "Chen"
val playerC: String = "Umberto"

// Change playerC from Marta to Umberto
//playerC = "Umberto" // Compilation Failed
```

---

## Mutable variables (var) and type inference

### Scala has two kinds of variables

1. `val` (immutable = once initialized, can't be re-assigned): a `val` is kind of like a `final` variable in Java.
2. `var` (mutable = can be re-assigned): a `var` is similar to a `non-final` variables in Java.

### Pros and cons of immutability

In Scala, we actually **prefer immutable variables (`val`s, that is)** where possible.

**Pros**

1. Your data won't be changed accidentally, by an error in your program's logic
2. Your code is easier to reason about since you don't have to mentally juggle all of the places where your data can change. 
3. Immutability means you'll have to write fewer unit tests to make sure your program works as expected.

**Cons**

The main drawback of immutability is the **extra memory** generated by copying objects. 
- Since vals can't be reassigned, to change them you'll need to create a new object. Your programs will be a little larger.

### Type inference is powerful

Using a powerful feature of Scala called **type inference**, we can make this code **even more concise**.


From:

```scala
val a: Int = 4
var b: Int = 1
```

To:

```scala
val a = 4
var b = 1
```

Scala can infer that `a` and `b` variables are Int because it knows whole numbers like 4 are typically meant to be integers.

Type inference not only applies to variables, but also collections, functions, and more.

### Semicolon can be excluded

Scala tries very hard to let us skip semicolons (;) at the end of each statement wherever possible to make our code even more concise.

From:

```scala
val a = 4;
var b = 1;
```

To:

```scala
val a = 4
var b = 1
```

---
